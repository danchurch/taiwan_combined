## start over, see if we can redo our original biom table construction. 


## we already rearranged the split barcodes on the leaf reads, is that 
## still laying around?

## they're here:

ls -lh /home/daniel/Documents/taiwan/taiwan_dada2/rearranged_leafR1.fastq
ls -lh /home/daniel/Documents/taiwan/taiwan_dada2/rearranged_leafR2.fastq

## let's make a link to these:



ln -s /home/daniel/Documents/taiwan/taiwan_dada2/rearranged_leafR1.fastq reLeafR1.fastq
ln -s /home/daniel/Documents/taiwan/taiwan_dada2/rearranged_leafR2.fastq reLeafR2.fastq

rm reLeafR*.fastq

## confused - it looks like I used to have an aggregate wood reads file, 
## all the R1s in one file, R2s in the other. 

## whatever it was, I don't have it anymore. 

## without this, do we just loop through the wood reads, trim as we go?

## wood directory

wooddir='/home/daniel/Documents/taiwan/woodreads/'

i='lane1-s257-index-GAGGACTT-CCTAAGTCNNNN-PosI_S257_L001_R1_001.fastq'

cut <(echo $i) -d "-" -f 1

echo $i 

for i in $wooddir*"_R1_"*; do 
    echo $i
done

fastx_trimmer -l 255 -i $i -o woodR1_trimmed.fastq
fastx_trimmer -l 210 -i woodR2.fastq -o woodR2_trimmed.fastq


## okay, but we don't have single wood forward and reverse files, 
## we have a forward and a reverse for each sample 

## so apply the trim across all reads in the wood files. 

## where are these?
wooddir=/home/daniel/Documents/taiwan/woodreads/


mkdir trimmed_wood
mkdir trimmed_wood/R1
mkdir trimmed_wood/R2

## trims.sh
########################################

wooddir=/home/daniel/Documents/taiwan/woodreads/

cd /home/daniel/Documents/taiwan/taiwan_combined_biom

R1trimdir='/home/daniel/Documents/taiwan/taiwan_combined_biom/trimmed_wood/R1/'

for i in $wooddir*_R1_*; do
    echo $i
    out=$R1trimdir$(basename ${i/_001\.fastq/_trimmed\.fastq}) 
    fastx_trimmer -l 255 -i $i -o $out && echo $out 
done

R2trimdir='/home/daniel/Documents/taiwan/taiwan_combined_biom/trimmed_wood/R2/'

for j in $wooddir*_R2_*; do
    echo $j
    out=$R2trimdir$(basename ${j/_001\.fastq/_trimmed\.fastq}) 
    fastx_trimmer -l 210 -i $j -o $out && echo $out 
done

########################################


time ./trims.sh

echo "zoop"

## and the leaf reads?

mkdir  trimmed_leaf
mkdir trimmed_leaf/R{1..2}

### okay, but I think we gotta do this on Talapas. 
## I recall it's sometimes weird using outputs from
## the 32-bit home version of usearch with the 64-bit
## software, etc, so best to stick with the 64bit
## version on Talapas...

scp reLeafR1.fastq dthomas@talapas-login.uoregon.edu:/projects/xylaria/dthomas 

scp reLeafR2.fastq dthomas@talapas-login.uoregon.edu:/projects/xylaria/dthomas 

## gotta get the wood reads (trimmed) there too:

scp trimmed_wood -r dthomas@talapas-login.uoregon.edu:/projects/xylaria/dthomas
cp trimmed_wood -r dthomas@talapas-login.uoregon.edu:/projects/xylaria/dthomas

## merging is next....

## on the new cluster (Talapas) the 
## batch info is included as comments
## in the script:

## merge_leaves.sh
###########################
#! /usr/bin/env bash

#SBATCH --job-name=merge_leaves
#SBATCH --output=merge_leaves.out
#SBATCH --error=merge_leaves.err
#SBATCH --time=0-04:00:00
#SBATCH --nodes=1

leafdir=/projects/xylaria/dthomas/leaf/

module load usearch/8.0

usearch -fastq_mergepairs $leafdir"reLeafR2.fastq" -reverse $leafdir"reLeafR1.fastq" -fastqout $leafdir"leafmerged.fastq"
usearch -fastq_mergepairs $leafdir"Roo_R2_trimmed.fastq" -reverse $leafdir"Roo_R1_trimmed.fastq" -fastqout $leafdir"leaftrimmedmerged.fastq"


################################

## didn't work. they don't have the license for
## usearch 64bit, just 32bit. 

## what file size can usearch 32-bit handle?
## our wood reads are demultiplexed, much 
## smaller, let's try these:

## merge_wood.sh
################################
#!usr/bin/env bash

#SBATCH --job-name=merge_wood
#SBATCH --output=merge_wood.out
#SBATCH --error=merge_wood.err
#SBATCH --time=0-05:00:00
#SBATCH --nodes=1

module load usearch/8.0

cd projects/xylaria/dthomas/

R1d=/projects/xylaria/dthomas/trimmed_wood/R1/

for forward in $R1d*; do 
    echo $forward
    reverse=${forward//R1/R2}
    aa=$(basename $forward); output="/projects/xylaria/dthomas/merged_wood/"${aa/_R1_trimmed.fastq/_merged.fastq}
    usearch -fastq_mergepairs $forward -reverse $reverse -fastqout $output
done

###########################

## did that work?

## looks good. So what was our largest file size?

ls -Slhr

## 51 meg. 

## our leaf files after trimming are 10 and 6.8 gig. 

## this largest file size is 374560 lines 

## let's split up the leaves in to files with line
## numbers in multiples of four.

## pipeline: 

## 1) split leaf and wood reads down to ~1 gig files
## 2) run usearch on all
## 3) combine with cat

## 1) split leaf into 1 gig files:

## trimmed, unpaired leaves are here in talapas:

cd /projects/xylaria/dthomas/leaf

## how many lines in these leaf read files?

wc -l Roo_R1_trimmed.fastq ## 72806460

wc -l Roo_R2_trimmed.fastq ## same, 72806460

expr 72806460 / 4 ## 18201615 reads... is that about right? 

## anyway, multiple of four

## we should probably write a script for this, get off the 
## head node:

## split_leaf.sh
################################

#!/bin/bash

#SBATCH --job-name=split_leaf
#SBATCH --output=split_leaf.out
#SBATCH --error=split_leaf.err
#SBATCH --time=0-05:00:00
#SBATCH --nodes=1

cd /projects/xylaria/dthomas/leaf/split_leaf

for i in ../Roo_R*_*; do 
    ls $i 
    split -d -l 500000 $i ${i/fastq/split\.fastq}
done


###########################


## Submitted batch job 1731251

## worked?:


cd /projects/xylaria/dthomas/leaf/split_leaf


expr 72806460 / 500000 ## should be 145 or so files:

for i in *; do
wc -l $i
done

## looks good, matches up
## can we cycle through these and merge?

######################

#!/bin/bash

#SBATCH --job-name=leaf_merge
#SBATCH --output=leaf_merge.out
#SBATCH --error=leaf_merge.err
#SBATCH --time=0-05:00:00
#SBATCH --nodes=1

module load usearch/8.0

cd /projects/xylaria/dthomas/leaf/split_leaf/

for i in Roo_R2_trimmed.split.fastq*; do
    usearch -fastq_mergepairs $i -reverse ${i/_R2_/_R1_}  -fastqout "merged/"${i/_R2_/_merged_} 
done

###################################

## seems like it worked...

scp dthomas@talapas-login.uoregon.edu:/home/dthomas/leaf_merge.out ./
scp dthomas@talapas-login.uoregon.edu:/home/dthomas/leaf_merge.err ./

## okay, can we recombine these? or is there an order issue now?

cat * > Roo_merged_trimmed.split.fastq

## that may be a bit much for the head node ...

srun --pty --partition=short --mem=1024M --time=60 bash

## rerun

ls -l Roo_merged_trimmed.split.fastq

wc -l Roo_merged_trimmed.split.fastq ## 65858336

expr 65858336 / 4 ## 16,464,584 reads. 

echo $((18201615 - 16464584)) ## 1,737,031 reads lost. 

## anyway, what happens next? 
## I think we next demultiplex our leaf reads. 

## but let's catch up the jupyter notebook...

## it looks like more than half of our wood reads didn't pair. 
## check this:

cd /projects/xylaria/dthomas/merged_wood

tot=0
for i in *; do
    tot=$(( $tot + $(wc -l $i | cut -f 1 -d " ") ))
done

echo $(( tot / 4 )) reads

## 1.86 million reads. Something is fucked. 

## so... what happened?

## if we rerun just one of our merges, do we get the same result?

## for instance, we got really bad results from our second file, 33% matched
## this is ... 

## lane1-s161-index-AAGCACTG-TTCGTACGNNNN-Dc-PosG_S161_L001_R1_trimmed.fastq

## to rerun this:

forward="/projects/xylaria/dthomas/trimmed_wood/R1/lane1-s161-index-AAGCACTG-TTCGTACGNNNN-Dc-PosG_S161_L001_R1_trimmed.fastq"
reverse="/projects/xylaria/dthomas/trimmed_wood/R2/lane1-s161-index-AAGCACTG-TTCGTACGNNNN-Dc-PosG_S161_L001_R2_trimmed.fastq"

module load usearch/8.0

usearch -fastq_mergepairs $forward -reverse $reverse -fastqout ./test.fastq

usearch -fastq_mergepairs $forward -reverse $reverse -fastqout ./test.fastq -notrunclabels

## get some error reports:

usearch -fastq_mergepairs $forward -reverse $reverse  -alnout aln.txt

usearch -fastq_mergepairs $forward -reverse $reverse -fastqout ./test.fastq -alnout aln.txt

## it looks like most of our reads aligned, ~95%, and they looks pretty good on visual 
## inspection, but we need to relax our permitted numbers of mismatches. 
## in newer versions, this is the  "-fastq_maxdiffs" parameter, defautl = 5. 
## True for 8.0?

usearch -fastq_mergepairs $forward -reverse $reverse -fastq_maxdiffs 10 -alnout aln_10.txt

usearch -fastq_mergepairs $forward -reverse $reverse -fastq_maxdiffs 20 -alnout aln_20.txt

## none of this is helping. "mismatches" and "differences" are different types of error in 
## this version, though not in the more recent versions. And I can't find documentation 
## for older versions. What is the difference between these errors? Most of our reads aligned
## very well.  

## let's try this on my own computer, with v8.1.x of usearch

forward='lane1-s161-index-AAGCACTG-TTCGTACGNNNN-Dc-PosG_S161_L001_R1_trimmed.fastq'
reverse='lane1-s161-index-AAGCACTG-TTCGTACGNNNN-Dc-PosG_S161_L001_R2_trimmed.fastq'

usearch -fastq_mergepairs $forward -reverse $reverse -fastqout ./test.fastq

## better results. Still not perfect (67%) but maybe that's okay. 

usearch -fastq_mergepairs $forward -reverse $reverse -fastq_maxdiffs 10 -fastqout ./test2.fastq

## even better, 

usearch -fastq_mergepairs $forward \
    -reverse $reverse \
    -fastq_maxdiffs 10 \
    -alnout aln_2.txt \
    -report test2.report.txt 

## maybe wiser to use a percentage?

usearch -fastq_mergepairs $forward \
    -reverse $reverse \
    -fastq_maxdiffpct 40 \
    -alnout aln_3.txt \
    -report test3.report.txt \
    -fastqout ./test3.fastq

## drops us back to 67.7%

## sleepy. Time for bed. 

## so in the future, need to rerun the merging for wood and split up leaf reads,
## because usearch 8.1 seems so much more forgiving that 8.0. 

## is there something I can set to running tonight?

## split up leaf files on the optiplex?
## run the merge on all of them?

## we need to 

## 1 get all trimmed wood onto the optiplex
## 2 and all trimmed leaves
## 3 install usearch 8.1 onto optiplex
## 4 split up the leaves
## 5 run mergepair on on all wood
## 6 run mergepair on on all leaf
## 7 recombine leaves
 

## or just sleep. Let's do that. 
